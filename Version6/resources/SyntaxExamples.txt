project1:
   package1:
      program1.lang
      program2.lang
   package2:
      program3.lang
   build.lang:
      public val package1 = import package1;
      private val package2 = import package2;
project2:
   main.lang:
      val package1 = import project1.package1;
      # Illegal: val package2 = import project1.package2;
   build.lang

# A folder on the file system can either be a project or package. A
# folder is a project if it contains a single build.lang file.
# Otherwise a folder is a package.

# A module is any file on the file system that ends with the .lang
# ending. A module is the base unit for compilation.

# The parent of a module, package, or project is the folder that
# immediatly contains it. A child is a module, package, or a project
# contained by a parent.

# Projects may contain other projects.

# Modules, Projects, and Packages are all namespaces for code.
   # A namespace is a hierarchical mapping from names to modules,
   # packages, or projects and does not imply compilation or execution.

   # The name of the module excluding the .lang ending is the
   # namespace for any given module.

   # importing any module, package, or project means importing it's
   # namespace and does not eagerly compile all modules unless
   # referenced

   # ambigous namespace between projects, packages, or modules is not
   # allowed and will result in a build error.

# A single build.lang file is allowed to exist in any folder.
# Otherwise the lang compiler will refuse to compile the code.

# All children of a project are implicity private except for the
# build.lang file which is public. A build.lang file can import
# projects, packages or modules. To import a child without exposing it
# under the projects namespace within the build.lang file, either
# ommit the publicity label (private # is implied) or write the
# private keyword followed by the import statement. To define a child
# as public under a project's namespace write an import statement
# inside the build.lang file that is prefixed with the public keyword.

# Cyclic dependencies are not allowed.
   # Tooling will be provided to help resolve cyclic depenencies.
# Upward dependencies are not allowed.
   # 1. A module may import folders or modules within the folder that
   # 	it is contained in.
   
   # 2. A module may import folders inside the folder that it's parent
   # 	folder is contained in. This does not apply transitivly.

   # 3. All other dependencies must be provided by the build.lang file
   #	and are imported using the import env.dependency syntax.

