Philosophy:
1. The type of every variable and expression must be known at compile
	time.
2. Types limit the values that a variable can hold.
3. Inheritance is not supported. Instead use composition.
4. Errors are values and participate in the type system. No special
	control flow is provided for errors. Instead use the regular
	regular control flow as you would for other values.
5. No undifined behaviour. Undefined behaviour based optimization only
	occurs when you assert your invariants.
6. The language is a self contained tool chain. Both the build system
	and command line interface are features handled by the language.
	Read more in the build system and command line interface sections.

epsilon > ;

lowercase > 'a' | 'b' | 'c' | ... | 'z';
uppercase > 'A' | 'B' | 'C' | ... | 'Z';
letter > lowerCase | uppercase;
digit > 0 | 1 | 2 | ... | 9;

identifier > identifierHead identifierTail;
identifierHead > '_' | letter;
identifierTail > '_' | letter | digit | epsilon;  

Comments:
	Comments begin with a '#' and end with '#' or a '\n'. Comments can
	therefore not contain a '\n' as it delimites a comment. Comments
	may contain \\ or \# where \# does not terminate a comment.
		... # this is a comment '\n'
		... # this is also a comment # ... '\n'
		... # \# <-- not the end -> \\\\\# and --> # ... '\n'

	Comments are not removed before parse time. Therefore:
		"print#bad comment#ln"
		
		is parsed as
		identifier print
		identifier ln

Fundamental Types:
	Lang has signed integers (i), unsigned integers (u) and floats (f).
	Lang's fundamental types can be any size N however each value of N
	will be rounded to the largest power of 2. The values that the type
	can hold is still limmited to relevant i, u, or f max size for 2^N
	bits.

	The syntax for a type is as follows:

	fundamentalType > L N;
	L > 'i' | 'u' | 'f';
	N > 1 | 2 | 3 | ... | 128;

	Example fundamental types:
		i8    u8    f8
		i16   u16   f16
		i24   u24   f24
		i32   u32   f32
		i64   u64   f64
		i128  u128  f128

	u7 is allocated as u8 in memory.
	u7's max value is 2^7 = 128

Literals:
	1. Integers:
		An integer is a series of digits of any length. -ve integers are
		handled through the expression grammar.

		integer > digit integer | epsilon;
		digit > 0 | 1 | 2 | 3 | ... | 9;

	2. Floats:
		A float is a series of digit like an integer followed by a '.' and
		another series of digits. Floats in the form "42." are illegal.
		Instead use "42.0".

		float > integer '.' integer;

		-ve floats are also handled through expressions.

	3. Hexidecimal:
		A hexidecimal number is a 0 followed by an uppercase or lowercase x
		followed by a series of hexidecimal digits.

		hex > 0 X hexTail;
		X > 'x' | 'X';
		hexTail > hexDigit hexTail | epsilon;
		hexDigit > 0 | 1 | 2 | ... | 9 | 'a' | 'b' | 'c' | ... | 'f';

	4. Binary:
		A binary number is a 0 followed by an upperace or lowercase b
		followed by a series of 0s or 1s.

		binary > 0 B binaryTail;
		B > 'b' | 'B';
		binartTail > zeroOrOne binaryTail | epsilon;
		zeroOrOne > 0 | 1;
	5. Strings:
		Strings have similar properites to comments. However there are
		two forms one with '"' as a drop in replacement for the '#' in
		comments and one with '\'' as the drop in replacement.

		A string with '"' may contain unescaped '\'' and vice versa.

		"\"I didn't tell you to 'kill' him\""
		'"I didn\'t tell you to "kill" him"'

Typed Literals:
	Any literal can be followed by a ':' and a fundamental type. This
	is used when the size of the literal in terms of memory is
	important as part of an expression. Additionally this syntax is
	used to disambiguate CLI calls of function. See the section on CLI
	for more information.

	Examples:
		5:i32				# an i32 with the value 5
		0xFFFFFFFF:u64 # a u64  with the value 0xFFFFFFFF
		4.5:f128			# a f128 with the value 4.5
		"c":u8			# a single ascii charachter

	See the section on arrays for typed literals of strings with more
	than one charachter.

Components:
	A component is an identier associated with a piece of memory.
	
	When defining a component the programmer must consider: 

		1. Publicity: Will the component be accessible outside of it's
		current scope?

			A component can either be public meaning visible outside of
			the current scope or private meaning only visible inside of
			the current scope.

			Publicty can be ommited when defining components. The default
			behaviour for publicity depends on the context in which a
			variable is declared.

			publicity > "public" | "private" | epsilon;

		2. Mutability:
			Will the data in the component be mutable?

			components can either be values or variables. Lang exclusivly
			uses their short forms "var" and "val" respectibly to mean
			mutable and imutable. Mutability cannot be ommited like
			publicity.

			Binding mutability is monotonic: a mutable binding (var) may
			be finalized into a immutable binding (val) but an immutable
			binding may never become mutable.

			mutability > "var" | "val";

		3. Type: What data will the variable be allowed to hold?

			Type is defined later in the section after objects.

			Type can be ommited only if the right hand side of the
			declaration is a literal. Strings will default to stack
			allocated array. u8[]. See arrays for more detail.

		4. Identifier: What will the variable be called?

			the earlier defined identifer definition is not sufficient. A
			keyword is also an identifier. All keywords are reserved
			identifiers and are illegal to use as component names.

		Examples (Best to Worst practice)
			public var i32 x = 5 
			var i32 x = 5

			public var x = 5:i32
			var x = 5:i32

			public var x = 5
			var x = 5

		The implicit capability is allowed only because people like it
		so much. The language stipulates rules however.

Arrays:
	An array is a fixed-size, contiguous collection of elements of the
	same type. All arrays in the language are statically sized.  There
	are no dynamically sized arrays. The size of an array is always
	known at compile time.

	Arrays are written using one of the following forms:
		T[N]             # An array of N elements of type T.

		T[]  or Array<T> # An array whose size is infered on
		initialization.

	T[] does not mean dynamic. Instead when an non explicitly sized
	array is declared, the compiler infers the size from the right hand
	side of the assignment. After type checking, every T[] becomes a
	fully sized T[N]. If the size cannot be determined at compile time,
	the program is invalid.

	Square braces are used to instantiate data strcutures. Genaric data
	structures prefix the square braces with their identifer. Since
	u8[] is equivalent to Array<u8> the Array identifier can prefix
	square braces for array instantiation.

	Arrays are zero initialized by default to the types specific
	default value. Array indexing is zero-based. 

	Examples:

		# inffered sizing
		var u8[] a = "text"      # becomes u8[4]
		var u8[] b = [1,2,3]     # becomes u8[3]
		# equivalent generics for arrays
		var Array<u8> ga = Array<>"text"  # ga.length is 4
		var Array<u8> gb1 = Array<>[1,2,3] # gb1.length is 3
		var Array<u8> gb2 = Array<u8>[1,2,3] # gb2.length is 3

		# non infered array size declatation
		var u8[4] sa    # single dimension array
		var u8[3][4] sb # mutli dimensional array.
							 # 3 rows, 4 collumns
		# equivalent generics for arrays
		var Array<u8> gsa = Array.create<u8>(4)
		var Array<Array<u8>> gsb = Array.create<u8>(3,4)

		print(sa)       # [0,0,0,0]
		print(sb)		 # [[0,0,0,0],[0,0,0,0],[0,0,0,0]]

		# 0 based indexing
		sa[0] = 1
		sb[1][2] = 2

		print(sa)       # [0,1,0,0]
		print(sb)		 # [[0,0,0,0],[0,0,2,0],[0,0,0,0]]
	
	Additional examples:
		var u8[]      t1  = "text"
		var u8[]		  t2  = 'text'
		var u8[]		  t3  = [116,101,120,116]
		var Array<u8> t4  = "text"
		var Array<u8> t5  = 'text'
		var Array<u8> t6  = [116,101,120,116]

		var u8[]      t7  = Array<>"text"
		var u8[]      t8  = Array<>'text'
		var u8[]      t9  = Array<>[116,101,120,116]
		var Array<u8> t10 = Array<>"text"
		var Array<u8> t11 = Array<>'text'
		var Array<u8> t12 = Array<>[116,101,120,116]

		#Note that other data types then Array cannot be assigned to [].
		#Illegal: var u8[] error = List<u8>"text"

		var u8[]      t13 = Array<u8>"text"
		var u8[]      t14 = Array<u8>'text;
		var u8[]      t15 = Array<u8>[116,101,120,116]
		var Array<u8> t16 = Array<u8>"text"
		var Array<u8> t17 = Array<u8>'text'
		var Array<u8> t18 = Array<u8>[116,101,120,116]

		var u8[4] t19
		var u8[3][4] t20
		#equivalent generic version
		#var Array<Array<u8>> t19 = Array.create<u8>(4)
		#var Array<Array<u8>> t20 = Array.create<u8>(3,4)

		print(t19) # [0,0,0,0]
		t8[2] = 1
		print(t19) # [0,0,1,0]

		print(t20)
		# [[0,0,0,0],
		#  [0,0,0,0],
		#  [0,0,0,0]]
		t9[1][2] = 1
		print(t20)
		# [[0,0,0,0],
		#  [0,0,1,0],
		#  [0,0,0,0]]

		# See pointers for more information
		# reasignable mutable slice
		var u8[]* p1 = "text" # pointer to an array of u8's
		# reasignable imutable slice
		var u8[]~ p2 = "text" # reference to an array of u8's
	
Rerferences, Pointers, and Slices:
	In assembly components are just an address and a region of memory.

	The variable x might exist at 0x00000000, be an i32 meaning it is 4
	bytes long, and have the value 5.

		var i32 x = 5 #0x00000000 00000000 00000000 00000000 0000o0101

	Some components memory region's might contain the address of
	another region of memory. The type system allows operations on the
	data at the memory address contained in these components. However
	there are several restrictions enforced by the type system to
	prevent dangerous behaviour due to this pattern.

	1. Borrowing (Aliasing rules)
		There are two patterns for address containing components.
		Firstly that the address containing component is iteself
		mutable or imutable denoted var or val. And secondly that the
		memory region at the address contained in the component is
		mutable or imutable. The latter is refered to as pointers and
		references respectivly.

		There can exist one pointer or infinite references to a given
		memory region at a time but not both. That is the existance of a
		references to a memory region and the existance of a pointer to
		a memory region are mutally exclusive.

		Borrowing:
		 - prevents data races.
		 - enables aggressive compiler optimizations.
		 - Makes aliasing explicit.

		Syntax example:
			var i32 x = 5
			{
				#The & operator generates a pointer to x.
				var i32* p1 = &x #p is a single pointer to x
			}
			{
				#The $ operator generate a reference to x.
				var i32 r1 = $x #r1 is one of one   references to x.
				var i32 r2 = $x #r2 is one of two   references to x.
				var i32 r3 = $x #r3 is one of three references to x.
			}
			{
				var i32* p1 = &x #mutably borrow from x
				var i32~ r1 = $x #borrow error: p1 allready is mutably
									  #borrowing from x.
				var i32~ r2 = $x #borrow error: p1 allready is mutably
									  #borrowing from x.
			}
			{
				var i32~ r1 = $x #imutably borrow from x
				var i32~ r2 = $x #imutably borrow from x
				var i32* p1 = &x #borrow error: r1 and r2 are allready
									  #imutably borrowing from x.
			}

	2. Ownership
		Every region of memory has exactly one owner at a time.

		 Ownership enables:
		 - the owner to decide when memory is freed.
		 - the pattern that when ownership moves, the old names becomes
			unusable.
		 - prevention of double-free and use-after-free patterns.

		Ownership exists in lang, but it is only a fiction enforced by
		the compiler. At runtime it is only still data at an address
		containing an address.

		Syntax example:
			# Ownership of the memory region containing the value 5
			# belongs to x. When x is dropped that memory region will be
			# deallocated from the stack because x is a stack variable.
			var i32 x = 5
			{
				var i32* p1 = &x
			} #p1 is dropped. Allowing new pointers xor referenes to
			  #exist.
			{
				var i32 r1 = $x
				var i32 r2 = $x
				var i32 r3 = $x
			} #r1, r2, and r3 are dropped. Allowing new pointers xor
		 	  #referces to exist.
			{
				var i32* p1 = &x
				var i32~ r1 = $x #Since p1 was not dropped, r1 is not
									  #allowed to exist.
				var i32~ r2 = $x #Since p1 was not dropped, r2 is not
									  #allowed to exist.
			}
			{
				var i32~ r1 = $x
				var i32~ r2 = $x
				var i32* p1 = &x #Since r1, and r2 were not dropped p1 is
									  #not allowed to exist.
			}

		All address containing components cannot be assigned arbitrary
		addresses directly or transitivly because it is not guaranteed
		that they can own the memory region at the address.
	
	3. Lifetimes (temporal validity)
		Pointers and references are valid only for a specific span of
		time.

		Pointers and references:
		 - must not outlive the memory they point to.
		 - must not be used after free.
		 - must not escape its owner.

		Lifetimes are enforced at compile time, not stored in memory and
		do not appear in assembly.

		var i32* p
		{
			var i32 x = 5
			p = &x
		}
		println(p) #Lifetime error. The memory region for x no longer
					  #exists.
	
	4. Slices
		Slices are pointers or references to continuous memory. They are
		also sometimes called fat pointer because they are represented
		as (address, length). Slices borrow ownership on the memory
		region that they point to. Operations that would invalidate or
		mutate that region of memory by the memory region's owner are
		illegal and enforced by lifetimes.

		var i32[] array = [0,1,2,3,4,5]
		var i32[]* s1 = array[0..2]
		var i32[]* s2 = array[1..4] #borrow error cannot mutably borrow
											 #from array[1..4], s1 currenly owns
											 #array[0..2] which overlaps [1..4]
											 #at [1..2]
		var i32[]~ r1 = array[2..5] #imutably borrow the rest of the
									  #array except the last one at pos 5.
									  # Legal because it doesn't overlap s1.

									    #slices
		var i32[]~ s3 = s1[0..2] #imutably borrow from s1 at 0 and 1.
		s1[0]++ #borrow error. s3 is immutably borrowing s1 at [0..2]
		array[5]++ #legal because array still owns pos[5]

	5. Owning heap memory: Heap<T> x
		Using the Heap<T> type defines a heap allocated T owned by the
		component x. When x is dropped the heap allocated T is freed.
		Additionally it cannot be aliased mutable without borrowing.

		Heap is an implementation of the Allocator interface.
		Everything that is allocated can be stored in the generic type
		Allocated that defines all the behaviour for memory safety.

		var Allocated<i32> x = Heap.create<i32>(5)
		var Allocated<i32> y = x #x is unusable
		println(x) #Borrow error. x was moved to y.

		when x is dropped the memory at the address in x is freed.
		Allocated<i32> can be abreviated to i32@ which is read a i32
		allocation. For 

	6. Rule breakers:
		a) Cell<T>
			Cell<T> is a mutable container that stores a value of type T.
			Mutation of the data contained by a cell is allowed only
			through read and write operations. Any operation that
			produces a reference or a pointer to the memory region
			indicated by the cell is illegal. By definition this is
			thread safe beucase no two threads can access the same memory
			region through one cell.
		b) RefCell<T>
			RefCell<T> indicates that the type T is runtime borrow
			checked instead of at compile time.
		c) Mutex<T> allows mutable access to the memory region of the
			component of type T. Memory safety is a result of exclusive
			access provided through locking.
		d) AtomicType (replace Type with the specific Atomic type)
			All atomic types support operations where the operations are
			indivisible. The CPU executes the entire operation in one
			unit.
		e) Rc<T>
			Reference counting is a fat pointer to the heap. Any number
			of Rc<T> types to the same heap memory is allowed to exist.
			When a new Rc<T> is set to point to the heap memory a
			references variable is incremented. When Rc<T> is dropped the
			variable is decremented. When the variable reaches zero the
			memory on the heap is freed.

			A reference-counted value may provide mutable access to its
			contained component only when the container itself is
			exclusivly borrowed. if the strong reference count equals one,
			the container may yield a pointer to the contained value
			otherwise, mutable access is denied. 
		f) Arc<T> 
			Atomic refrence counting is the same as reference counting
			however it is thread safe. All operations on an Arc are
			atomix. That is the increment and decrement of the references
			count for the Arc<T> are executed in a single unit by the
			cpu. 

Control Flow:
	if and match are expression and can be used anywhere where an
	expression is valid. They can be used for control flow as
	statements.

	if condition {

	} else if condition {

	} else {

	}

	match condition {
		case1: {
		}
		_: ...
	}

	loop {

	}

	loop while condition {

	}

	loop {

	} while condition
	

	loop i32 x in 0..10 {

	}

	loop u8[] str in ["hello","world"] {
		println(str)
	}

	label ID # mark a point that can be jumped to
	jump # goto a line number or a labeled ID#
	continue # move onto the next iteration of the loop
	yield # output a result from an if expression or match expression
	return # return a result from a function


Functions:
	The language is 100% functional. Methods are supported only a
	semantic sugar for functions. 

	functionDecl > publicity "def" ID '(' parameters ')' block;

	1. Return type is inffered through what is returned. If multiple
		types are returned then the return type of the function is a
		enum of all the types.

		def foo(i32 x, i32 y) {
			return x / y
		}

		Expressions can result in a huge list of errors. The easiest way
		to handle such an error is to allow an illegal assignment error
		with a type mismatch.

		var i32 x = 1 / 0 # error.IllegalAssignment:
									# lhs = i32
									# rhs = error.DivideByZero.

		# handling it manually:
		var i32 x = match 1 / 0 {
			i32 v: v
			Error e: {
				return error.IllegalAssignment<i32,error.DividideByZero>()
			}
		}

		In this case for foo it's return type is a tagged union of an
		error and a i32. And would have to be handled similarily as to
		what was described above.

	2. Methods are semantic sugar for functions. Any function that
		takes atleast one parameter, given that the first parameter is
		not a vararg can be called like a method on the type of the
		first parameter so long as no method with the same name is
		defined for the type.

		public def toString(i32 x) {
			return 2
		}
		public def isMeaningOfLife(i32 x) {
			if x == 42 {
				return "yes"
			}
			return "no"
		}

		var i32 x = 5
		println(x.toString()) # prints 5; toString from i32 namespace
		println(toString(x))  # prints 2; toString from local namespace
		println(x.isMeaningOfLife()) # prints no; i32 method from local namespace
		println(isMeaningOfLife(x)) # prints no; i32 function from local namespace

		if a functions first argument is an enum it can opperate on any
		of those types.

	3. Functions can operate on variable or value components
		differently. Lack of var or val on parameters is assumed to mean
		imutable.

		var i32 x = 5
		val i32 y = 10

		def behaviour(var i32 x) {
			println("mutable!")
		}
		def behaviour(val i32 x) {
			println("imutable!")
		}
		x.behaviour() # prints mutable
		y.behaviour() # prints imutable

	4. Functions can be generic. Generics are evaluated for
		Compatibility. The compiler doesn't actually care all that much
		as long as what you input satisfies the requirements to
		function. Illegal behaviour is prevented without code
		generation.

		import std
		def heapAllocate<T>() {
			var T* ptr = std.heap.create<T>()
			return ptr
		}

		var i32* p = heapAllocate<i32>()
		var u8[]* str = heapAllocate<u8[]>()

	5. Optional parameters can be ommited when calling the function.
		def foo(i32? y) {
			#i32? is identical to Optional<i32>
			if y == null {
				println("Ommited or null")
			} else {
				println(y)
			}
		}

		foo() #Prints ommited or null
		foo(5) #Prints 5

Objects:
	structs and interfaces both define a layout of components in
	memory. A struct has all it's components public by default and a
	class has all it's components private by default. Interfaces and
	enums assume public by default. An interface defines functionallity
	that any struct, class, or enum must have. It can define default
	behaviour. Usage of self in interfaces is illegal.

	Enums have an usigned integer value
	associated and a certain size of memory associated with them.
	Components that an enum contains are overlapped such that the size
	of the enum is the size of the unsigned integers plus the largest
	component size. The unsigned integer is used to determine which
	component or components the enum actually contains.

	import std.allocator.heap as Heap
	struct Point {
		var i32 x
		val i32 y

		def create(Point* point, i32 x, i32 y) {
			*point = Point{x,y}
			return point
		}
		def create(i32 x, i32) {
			return Point{x,y}
		}

		private def foo() {
			println("Can't be called outside of this struct")
		}
	}
	class Person {
		var Heap<u8[]> name
		var u8 age

		public def create(u8[] name, u8 age) {
			return Person{name,age}
		}
		public def create(Person* person,u8[] name, u8 age) {
			person.name = Heap.create<u8[]>(name)
			person.age = age
			return person
		}
		public def ageUp(Person* self) {
			self.age += 1
		} 
		def dance(Person* self) {
			println("{name} doesn't dance in public.")
		}
	}
	
	var Point point1 = Point.create(5,5)
	var Allocated<Point> point2 = Heap.create<Point>(5,5)

	println(point1, point1.x, point1.y) #all good
	Point.foo() #Error foo is private to foo.
	
	var Arena<Person> people = Heap.create<Arena<Person>>(100)
	var Allocated<Person> person1 = people.create("Steve",18)
	var Person@ person2 = people.create("Jeff", 27)
	*person1 = Person.create(*person1,"Bob",42)

	enum TypedUnionEssentially {
		PERSON(Person@ person)
		POINT(Point@ point)
		OTHER

		def toString(TypedUnionEssentially e) {
			match e {
				PERSON: {
					println("A person: {e.person})
				}
				POINT: {
					println("A point: {e.point})
				}
				_: {
					println("OTHER")
				}
			}
		} 
	}
	interface Speaks {
	}
