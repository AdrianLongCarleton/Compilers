https://github.com/AdrianLongCarleton/CompilersGrammar and syntax:

Linguistics defines a grammar as the structure of a language. From a
top down perspective a grammar is a collection of transformation that
can be used to produce any given sentance that a grammar can describe.
A transformation is structured as an input, a '>' as a seperator, and
a output followed by a ';' to mark the end of the rule.

input > output;

node that '>' means produces. The rule reads: "input produces output."

The most powerfull transformations are inutile for coding language
design and follow the format where multiple 'words' are on the left
hand side of the '>' and multiple 'words' are on the right hand side
of the '>'.

left hand side > right hand side;

This preceding rule is used in context sensitive grammars like the
english language. For coding languages we restrict ourselves to
context free grammars in the form.

oneThingOnTheRightHandSide > multiple things on the right hand side;

This is usefull because you can construct trees structures.

For example the grammar.
A > B;
B > C;
B > D;
can be represented as a tree:
A -> B -> C
     |
     v
     D

Next we add some special terms.
Terminals occur in the right hand side are any word that does not
produce another nonTerminal.
non terminals may occur on either side and can produce terminals or
other non terminals. When ever a digit: 2, a char: 'c' or a string: "text"
or the words epsilon or any occur they are terminals. Everything else is a non
terminals.

The any terminal is place holder terminal for any other terminal
except epsilon.

The terminal epsilon specifically means nothing.
If we have a grammar:
nonTerminal > "hello world! " nonTerminal;
nonTerminal > epsilon;
We can read this in english as:
nonTerminal produces the string "hello world" followed by itself.
and
nonTerminal produces nothing.
It can therefore be reasoned about that this grammar represents a
any number of string "hello world" repeated over and over.
nonTerminal -> "hello world" nonTerminal;
                                  |
                                  v
                             "hello world" nonTerminal;
                                                |
                                                v
                                             epsilon;
In essence "hello worldhello worldhello world..." is a recognized
sentance according to this grammar.

sentance > "nice" 4 'u';

One more thing.
digit > 0;
digit > 1;
digit > 2;
digit > 3;
digit > 4;
digit > 5;
digit > 6;
digit > 7;
digit > 8;
digit > 9;

Can be succinclty written as:
digit > 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
Where '|' means and. The previous rule can therefore be read as:
digit produces 0 and 1 and 2 and 3 and 4 and 5 and 6 and 7 and 8 and
9. 

And even more succinctly:
digit > 0 | ... | 9;
Which can be read as digit produces the digits 0 up to 9.

The happy medium is usually:
digit > 0 | 1 | 2 | ... | 9; 
To give a bit more clarity.

Lastly keep in mind that any grammar written in this documment is only
for demonstrational purposes and does not always map 1 to 1 to how it
is implemented in the parser.

Philosophy:
1. The type of every variable and expression must be known at compile
   time.
2. Types limit the values that a variable can hold.
3. Inheritance is not supported. Instead use composition.
4. Errors are values and participate in the type system. No special
   control flow is provided for errors. Instead use the regular
   regular control flow as you would for other values.
5. No undifined behaviour. Undefined behaviour based optimization only
   occurs when you assert your invariants.
6. The language is a self contained tool chain. Both the build system
   and command line interface are features handled by the language.
   Read more in the build system and command line interface sections.

Comments:
The language does not support multiline comments. Comments begin with
a '#' and end with one of EOF, '\n', or '#'. Comments may contain
escaped '\\' or '\#'

Numeric Types:

There are three numeric types in the language. Unsigned integers,
Signed integers, and Floats. There is no char type or string type. A
literal begins with one of the following charachters 'u', 'i', or 'f'
for (u)nsigned integer, signed (i)nteger, and (f)loat respectivly.
After the type charachter each literal is followed by it's size N
which is a positive integer in the range 1 to 128. If the size N is
not a power of two it will be padded to the next largest power of 2
number of bits and have its max size enforced.

Syntax:

numericType > signedIntegerLiteral
            | unsignedIntegerLiteral
            | floatLiteral
            ;
signedIntegerLiteral > 'i' numericTypeSize;
unsignedIntegerLiteral > 'u' numericTypeSize;
floatLiteral > 'f' numericTypeSize;
numericTypeSize > 1 | ... | 8 | ... | 16 | ... | 64 | ... | 128;

Example numeric types:
i8    u8    f8
i16   u16   f16
i24   u24   f24
i32   u32   f32
i64   u64   f64
i128  u128  f128

Note that there are no string types. String must be implemented using
data structures and will be covered later.

Numeric literals:

The language supports numeric literals the following forms:
1. Integers:
   An integer is a series of digits of any length. -ve integers are
   handled through the expression grammar.

   integer > digit integer | epsilon;
   digit > 0 | 1 | 2 | 3 | ... | 9;

2. Floats:
   A float is a series of digit like an integer followed by a '.' and
   another series of digits. Floats in the form "42." are illegal.
   Instead use "42.0".

   float > integer '.' integer;
   
   -ve floats are also handled through expressions.

3. Hexidecimal:
   A hexidecimal number is a 0 followed by an uppercase or lowercase x
   followed by a series of hexidecimal digits.

   hex > 0 X hexTail;
   X > 'x' | 'X';
   hexTail > hexDigit hexTail | epsilon;
   hexDigit > 0 | 1 | 2 | ... | 9 | 'a' | 'b' | 'c' | ... | 'f';

4. Binary:
   A binary number is a 0 followed by an upperace or lowercase b
   followed by a series of 0s or 1s.

   binary > 0 B binaryTail;
   B > 'b' | 'B';
   binartTail > zeroOrOne binaryTail | epsilon;
   zeroOrOne > 0 | 1;

String literals:

String literals follow the syntax:
str > '"' strBody strEnd;
strBody > strChar strBody | epsilon;
strChar > '\' escapable | safeChar;
safeChar > any except '"' '\' '\n';
escapable > '\' | '"';

Strings begin with quoation mark may have escaped '\"' may not cross
'\n' boundaries and end with quotation mark. Note that a singe quote
is interchangeable for the double quote. Different quotes may nest
without interfereing. "the man said 'hello' and \"cheese\"". or 'the
man said "hello" and \'cheese\''.

Arrays:

array > ID_opt '[' elements ']';
ID_opt > "Array" | epsilon;
elements > integer ',' elements | integer;

Node that where Array was written any valid identifier for a generic
data structure may be written. Additionally where elements is written
is inacurate. See arguments for functions for more detail.

Array['a','b','c','d']
is equiavalent to
['a','b','c','d']
is not the same as
List['a','b','c','d']

"abcde"
'abcde'
String literals are semantic sugar for arrays like the following.
['a','b','c','d','e']

String get reduced to their array representation at compile time. For
that reason generic data types that take in u8 may be called as:

List"abcde"

Declaring components / fields:

When defining components in lang the programer must consider.
1. Publicity:
   Will the component be accessible outside of it's current scope?

   A component can either be public meaning visible outside of the
   current scope or private meaning only visible inside of the current
   scope.

   Publicty can be ommited when defining components. The default
   behaviour for publicity depends on the context in which a variable
   is declared.

   publicity > "public" | "private" | epsilon;
2. Mutability:
   Will the data in the component be mutable?

   components can either be values or variables. Lang exclusivly uses
   their short forms "var" and "val" respectibly to mean mutable and
   imutable. Mutability cannot be ommited like publicity.

   Binding mutability is monotonic: a mutable binding (var) may be
   finalized into a immutable binding (val) but an immutable binding
   may never become mutable.

   mutability > "var" | "val";

3. Type:
   What data will the variable be allowed to hold?

   Type is defined later in the section after objects.

4. Identifier:
   What will the variable be called?

   An identifier is any valid component name that is not a keyword.

Examples:
   
   # Equivalent declaration of the the variable component x.
   # In order of best to worst.
      # With type hints
      private var i32 x = 5
      var i32 x = 5
      
      # With typed number literals
      private var x = 5:i32
      var x = 5:i32

      # Without type hints
      private var x = 5
      var x = 5
   
   # Typed number literals are for initialization operations where an
   # expression needs another type then i32 to hand overflow,
   # underflow or saturation conditions. They also resolve ambiguity
   # the command line interface.

   It is better to use the first

Control Flow, Excluding flags:

Functions:
function and lambdas have parameters and operate on the arguments to
evaluate a collection of statements in order to return a result.

the return type of a lambda or function is not declared explicitly in
the syntax. Instead the return type is infered by what is return
within the function. If a function returns only a single type, for
example an int then the return type of that function is an int.
Otherwise the function returns an enum of the possible result types.
See objects for further detail on enums.

Syntax:

Note that type is currently undefined, see after the section on
objects for the definition.

functionDecl > publicity "def" ID '(' parameters ')' block;
parameters > vararg identifer parametersTail;
vararg > type varargTail;
varargTail > "..." | epsilon;
parametersTail > ',' parameters;
block > '{' statements '}';

functionCall > ID '(' arguments ')';
argumentsOpt > arguments | epsilon;
arguments > argumentBody argumentsBlock;
argumentsBody > argument argumentBodyOpt;
argumentsBodyOpt > ',' argumentsBody | epsilon;
argumentsBlock > ';' arguments | epsilon;
argument > integer | ... | float | string | identifier;

arguments(argumentsBody(argument(1) argumentsBodyOpt(',' 
argumentsBody(argument(2) argumentBodyOpt(',' argumentsBody(argument(
3) argumentBodyOpt()))))) argumentsBlock(';' arguments(argumentsBody(
argument(4) argumentsBodyOpt(',' argumentBody(argument(5)
argumentBodyOpt()))) argumentsBlock(';' arguments(argumentBody(
argument(6) argumentBodyOpt()) argumentsBlock())))))

public def foo(i32... vararg, u8[] text) {
   println(vararg)
   println(text)
   return 5
}
# foos return type is i32



Objects:
Objects are a type of component that contains other components.
There are four types of objects: struct, class, enum, and
interface.

Memory Allocation and Pointers.

Memory Allocation happens through the Allocator interface.
std.Allocator provides several allocators and is the only way to
explicitly access the heap and stack allocator.

Both pointers and references are variables that contain an address to
a memory location. Pointers have the right to mutate the data they
point at and references do not. Pointers can point to the stack or the
heap. References can point only to the stack.

Assignment to a pointer is always a move. if p2 is assigned to p1 then
p1 first releases it's memory. (Destroying a pointer with a pointer to
the stack is a nop) Then the assigned is completed. Finally p2 is set
to null.
Assignment to a reference is only legal in the scope it was created
in. Assigning a reference address to pointer address is illegal.Memory Allocation and Pointers.

Memory Allocation happens through the Allocator interface.
std.Allocator provides several allocators and is the only way to
explicitly access the heap and stack allocator.

Both pointers and references are variables that contain an address to
a memory location. Pointers have the right to mutate the data they
point at and references do not. Pointers can point to the stack or the
heap. References can point only to the stack.

Assignment to a pointer is always a move. if p2 is assigned to p1 then
p1 first releases it's memory. (Destroying a pointer with a pointer to
the stack is a nop) Then the assigned is completed. Finally p2 is set
to null.
Assignment to a reference is only legal in the scope it was created
in.

the * symbol in postfix means pointer
the * symbol in prefix  means dereference
the ~ symbol in postfix means reference
the & symbol in prefix means address

Explicit and implicit stack allocation:
   var i32 x = 5 # Implicit
   var i32* y = std.allocator.stack.create<i32>(5) #Explicit

Explicit and implicit heap allocation:
   var i32* x = 5 # implicit
   var i32* y = std.allocator.stack.create<i32>(5) # explicit

References and pointers are borrow checked.
   In rust terms a pointer   is a  mutable borrow
             and a reference is a imutable borrow
Ex1:
   var i32 x = 5
   var i32* p1 = &x # single mutable borrow
   var i32* p2 = &x # borrow error
   var i32~ r1 = &x # borrow error

Ex2:
  var i32 x = 5
  var i32* p1 = &x
  var i32* p2 = p1 # implicit p1 = null

Ex3:
  var i32 x = 5
  var i32~ r1 = &x
  var i32~ r2 = &x
  ...
  var i32~ rN = &x
  var i32* p1 = &x # borrow error
  var i32* p1 = r1 # borrow error

the * symbol in postfix means pointer
the * symbol in prefix  means dereference
the ~ symbol in postfix means reference
the & symbol in prefix means address

Explicit and implicit stack allocation:
   var i32 x = 5 # Implicit
   var i32* y = std.allocator.stack.create<i32>(5) #Explicit

Explicit and implicit heap allocation:
   var i32* x = 5 # implicit
   var i32* y = std.allocator.stack.create<i32>(5) # explicit

References and pointers are borrow checked.
   In rust terms a pointer   is a  mutable borrow
             and a reference is a imutable borrow
Ex1:
   var i32 x = 5
   var i32* p1 = &x # single mutable borrow
   var i32* p2 = &x # borrow error
   var i32~ r1 = &x # borrow error

Ex2:
  var i32 x = 5
  var i32* p1 = &x
  var i32* p2 = p1 # implicit p1 = null

Ex3:
  var i32 x = 5
  var i32~ r1 = &x
  var i32~ r2 = &x
  ...
  var i32~ rN = &x
  var i32* p1 = &x # borrow error
  var i32* p1 = r1 # borrow errorA struct has all of it's child component private by default.

Memory Allocation and Pointers.

Memory Allocation happens through the Allocator interface.
std.Allocator provides several allocators and is the only way to
explicitly access the heap and stack allocator.

Both pointers and references are variables that contain an address to
a memory location. Pointers have the right to mutate the data they
point at and references do not. Pointers can point to the stack or the
heap. References can point only to the stack.

Assignment to a pointer is always a move. if p2 is assigned to p1 then
p1 first releases it's memory. (Destroying a pointer with a pointer to
the stack is a nop) Then the assigned is completed. Finally p2 is set
to null.
Assignment to a reference is only legal in the scope it was created
in.

the * symbol in postfix means pointer
the * symbol in prefix  means dereference
the ~ symbol in postfix means reference
the & symbol in prefix means address

Explicit and implicit stack allocation:
   var i32 x = 5 # Implicit
   var i32* y = std.allocator.stack.create<i32>(5) #Explicit

Explicit and implicit heap allocation:
   var i32* x = 5 # implicit
   var i32* y = std.allocator.stack.create<i32>(5) # explicit

References and pointers are borrow checked. 
   In rust terms a pointer   is a  mutable borrow
             and a reference is a imutable borrow
Ex1:   
   var i32 x = 5
   var i32* p1 = &x # single mutable borrow
   var i32* p2 = &x # borrow error
   var i32~ r1 = &x # borrow error

Ex2:
  var i32 x = 5
  var i32* p1 = &x
  var i32* p2 = p1 # implicit p1 = null

Ex3:
  var i32 x = 5
  var i32~ r1 = &x
  var i32~ r2 = &x
  ...
  var i32~ rN = &x
  var i32* p1 = &x # borrow error
  var i32* p1 = r1 # borrow error









Build system:

project1:
   package1:
      program1.lang
      program2.lang
   package2:
      program3.lang
   build.lang:
      public val package1 = import package1;
      private val package2 = import package2;
project2:
   main.lang:
      val package1 = import project1.package1;
      # Illegal: val package2 = import project1.package2;
   build.lang

A folder on the file system can either be a project or package. A
folder is a project if it contains a single build.lang file.
Otherwise a folder is a package.

A module is any file on the file system that ends with the .lang
ending. A module is the base unit for compilation.

The parent of a module, package, or project is the folder that
immediatly contains it. A child is a module, package, or a project
contained by a parent.

Projects may contain other projects.

Modules, Projects, and Packages are all namespaces for code.
   A namespace is a hierarchical mapping from names to modules,
   packages, or projects and does not imply compilation or execution.

   The name of the module excluding the .lang ending is the
   namespace for any given module.

   importing any module, package, or project means importing it's
   namespace and does not eagerly compile all modules unless
   referenced

   ambigous namespace between projects, packages, or modules is not
   allowed and will result in a build error.

A single build.lang file is allowed to exist in any folder.
Otherwise the lang compiler will refuse to compile the code.

All children of a project are implicity private except for the
build.lang file which is public. A build.lang file can import
projects, packages or modules. To import a child without exposing it
under the projects namespace within the build.lang file, either
ommit the publicity label (private is implied) or write the
private keyword followed by the import statement. To define a child
as public under a project's namespace write an import statement
inside the build.lang file that is prefixed with the public keyword.

Cyclic dependencies are not allowed.
   Tooling will be provided to help resolve cyclic depenencies.
Upward dependencies are not allowed.
   1. A module may import folders or modules within the folder that
      it is contained in.

   2. A module may import folders inside the folder that it's parent
      folder is contained in. This does not apply transitivly.

   3. All other dependencies must be provided by the build.lang file
      and are imported using the import env.dependency syntax.

Import syntax:

For all files except for build.lang:

importStatement > "val" ID = "import" importBody;
importBody > "env" '.' importBodyTail | ID importBodyTail;
importBodyTail > '.' ID importBodyTail | epsilon;
      
For build.lang:

importStatement > publicity "val" ID = "import" importBody;
importBody > "dependency" importDependency | ID importBodyTail;
importDependency > STR
                 | "github" importBodyTail
                 | "cache" importBodyTail
                 ;
importBodyTail > '.' ID importBodyTail | epsilon;

When build.lang uses the dependency keyword and compilation begins
build.lang will resolve all the dependencies and register them as
accessible under env keyword. 

The cache keyword refers to the cache of projects that are saved on
the system / machine that the build is executing on.

Command Line Interface:

flag version {
   println(42)
}
flags {
   o(u8[]* filePath) {
      println(*filePath);
   }
   logName {
      println(name)
   }
}
program --version -o "thing" --logname
42
program -o "thing" --logname
thing
name
program --logname -o "thing"
name
thing
program -o "thing"
thing
program --logname
name
program -o --version
42
# Flag must occur
flag required(u8[]* criticalInfo) {
   println("This is important: {criticalInfo}")
} else {
   return std.CLI.error.required(required)
}
# One of a set of flags must occur
flags flags {} else {
   return std.CLI.error.requiredOneOf(flags)
}
# All of the flags in a set must occur
flags {
   f1 {
   } else {
      return std.CLI.error.required(f1)
   }
   f2 {
   } else {
      return std.CLI.error.required(f2)
   }
}
# All of the flags must occur but in any order.

Flags can be prefixed with the comptime keyword. Doing so will
inline the code block depending on if the flag is passed
into the compiler.

All flags that the compiler for lang use are reserved and are thus
illegal to use as comptime identifiers. Usage will result in an
Error.IllegalFlagIdentifier.

program.lang
   comptime flag debug {
      println("Hello World")
   } else {
      println("Goodbye World")
   }

lang program.lang -o compiled --debug
./compiled
Hello World
lang program.lang -o compiled
./compiled
Goodbye World

   ImplementationDetails:
      The text in the terminal is parsed by the compiled executable.
      
      var bool[] flags = Array(3)
      val <var bool[]>* flags = Array(std.allocator.heap,3) 

